using Newtonsoft.Json;
using QRiskTree.Engine.Facts;
using System.Xml.Linq;

namespace QRiskTree.Engine.Model
{
    [JsonObject(MemberSerialization.OptIn)]
    public class Vulnerability : NodeWithFacts
    {
        internal Vulnerability() : base(RangeType.Percentage)
        {
        }

        internal Vulnerability(string name) : base(name, RangeType.Percentage)
        {
        }

        #region Children management.
        public ThreatCapability AddThreatCapability()
        {
            var result = new ThreatCapability();
            if (!Add(result))
            {
                throw new InvalidOperationException("A ThreatCapability node already exists as a child of this node.");
            }
            return result;
        }

        public ThreatCapability AddThreatCapability(string name)
        {
            var result = new ThreatCapability(name);
            if (!Add(result))
            {
                throw new InvalidOperationException("A ThreatCapability node already exists as a child of this node.");
            }
            return result;
        }

        public ThreatCapability? GetThreatCapability()
        {
            return _children?.OfType<ThreatCapability>().FirstOrDefault();
        }

        public ResistenceStrength AddResistenceStrength()
        {
            var result = new ResistenceStrength();
            if (!Add(result))
            {
                throw new InvalidOperationException("A ResistenceStrength node already exists as a child of this node.");
            }
            return result;
        }

        public ResistenceStrength AddResistenceStrength(string name)
        {
            var result = new ResistenceStrength(name);
            if (!Add(result))
            {
                throw new InvalidOperationException("A ResistenceStrength node already exists as a child of this node.");
            }
            return result;
        }

        public ResistenceStrength? GetResistenceStrength()
        {
            return _children?.OfType<ResistenceStrength>().FirstOrDefault();
        }
        #endregion

        #region Member overrides.
        protected override bool IsValidChild(Node node)
        {
            return (node is ThreatCapability && !(_children?.OfType<ThreatCapability>().Any() ?? false)) ||
                (node is ResistenceStrength && !(_children?.OfType<ResistenceStrength>().Any() ?? false));
        }

        protected override bool HasAllChildren()
        {
            return (_children?.OfType<ThreatCapability>().Any() ?? false) &&
                (_children?.OfType<ResistenceStrength>().Any() ?? false);
        }

        protected override bool Simulate(uint iterations, out double[]? samples, out Confidence confidence)
        {
            var result = false;
            samples = null;
            confidence = Confidence;

            var threatCapability = _children?.OfType<ThreatCapability>().FirstOrDefault();
            var resistenceStrength = _children?.OfType<ResistenceStrength>().FirstOrDefault();

            if (threatCapability != null && resistenceStrength != null)
            {
                if (Simulate(threatCapability, iterations, out var tcSamples) && 
                    (tcSamples?.Length ?? 0) == iterations &&
                    Simulate(resistenceStrength, iterations, out var rsSamples) && 
                    (rsSamples?.Length ?? 0) == iterations)
                {
                    // Assign to samples 1 if the Threat Capability is higher than the Resistence Strength, otherwise zero.
                    samples = new double[iterations];
                    for (int i = 0; i < iterations; i++)
                    {
#pragma warning disable CS8602 // Dereference of a possibly null reference.
                        samples[i] = (tcSamples[i] > rsSamples[i]) ? 1.0 : 0.0;
#pragma warning restore CS8602 // Dereference of a possibly null reference.
                    }

                    confidence = threatCapability.Confidence < resistenceStrength.Confidence
                        ? threatCapability.Confidence
                        : resistenceStrength.Confidence;

                    result = true;
                }
            }

            return result;
        }
        #endregion
    }
}
